<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flag Bounce Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const FlagBounceGame = () => {
          const canvasRef = useRef(null);
          const [winner, setWinner] = useState(null);
          const [winnerName, setWinnerName] = useState('');
          const [flagsRemaining, setFlagsRemaining] = useState(0);
          const [roundNumber, setRoundNumber] = useState(1);
          const [isPaused, setIsPaused] = useState(false);
          const [confetti, setConfetti] = useState([]);
          const [recentWinners, setRecentWinners] = useState([]);
          const [showWinner, setShowWinner] = useState(false);
          const flagsRef = useRef(null);
          
          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = 1200;
            const height = 900;
            
            const centerX = width / 2;
            const centerY = height / 2 - 100;
            const radius = 200;
            
            const rect = {
              width: 650,
              height: 800,
              get x() { return centerX - this.width / 2; },
              get y() { return centerY - this.height / 2 + 130; }
            };
            
            let rotation = 0;
            
            const countryNames = {
              'üá∫üá∏': 'United States', 'üá¨üáß': 'United Kingdom', 'üá®üá¶': 'Canada', 'üá¶üá∫': 'Australia', 'üá©üá™': 'Germany',
              'üá´üá∑': 'France', 'üáÆüáπ': 'Italy', 'üá™üá∏': 'Spain', 'üá≥üá±': 'Netherlands', 'üá∏üá™': 'Sweden',
              'üá≥üá¥': 'Norway', 'üá©üá∞': 'Denmark', 'üá´üáÆ': 'Finland', 'üáµüá±': 'Poland', 'üá®üáø': 'Czech Republic',
              'üá¶üáπ': 'Austria', 'üá®üá≠': 'Switzerland', 'üáßüá™': 'Belgium', 'üáÆüá™': 'Ireland', 'üáµüáπ': 'Portugal',
              'üá¨üá∑': 'Greece', 'üá∑üá¥': 'Romania', 'üá≠üá∫': 'Hungary', 'üá∑üá∫': 'Russia', 'üá∫üá¶': 'Ukraine',
              'üáØüáµ': 'Japan', 'üá∞üá∑': 'South Korea', 'üá®üá≥': 'China', 'üáÆüá≥': 'India', 'üáπüá≠': 'Thailand',
              'üáªüá≥': 'Vietnam', 'üáµüá≠': 'Philippines', 'üáÆüá©': 'Indonesia', 'üá≤üáæ': 'Malaysia', 'üá∏üá¨': 'Singapore',
              'üáπüáº': 'Taiwan', 'üá≠üá∞': 'Hong Kong', 'üá≥üáø': 'New Zealand', 'üáøüá¶': 'South Africa', 'üá¶üá™': 'UAE',
              'üá∏üá¶': 'Saudi Arabia', 'üáπüá∑': 'Turkey', 'üáÆüá±': 'Israel', 'üá™üá¨': 'Egypt', 'üá≤üáΩ': 'Mexico',
              'üáßüá∑': 'Brazil', 'üá¶üá∑': 'Argentina', 'üá®üá±': 'Chile', 'üá®üá¥': 'Colombia', 'üáµüá™': 'Peru',
              'üáªüá™': 'Venezuela', 'üá™üá®': 'Ecuador', 'üá®üá∑': 'Costa Rica', 'üáµüá¶': 'Panama', 'üá®üá∫': 'Cuba',
              'üáØüá≤': 'Jamaica', 'üá≥üá¨': 'Nigeria', 'üá∞üá™': 'Kenya', 'üá¨üá≠': 'Ghana', 'üá™üáπ': 'Ethiopia',
              'üáµüá∞': 'Pakistan', 'üáßüá©': 'Bangladesh', 'üá±üá∞': 'Sri Lanka', 'üá≥üáµ': 'Nepal', 'üá∞üáø': 'Kazakhstan',
              'üá≤üá¶': 'Morocco', 'üáπüá≥': 'Tunisia', 'üáØüá¥': 'Jordan', 'üá±üáß': 'Lebanon'
            };
            
            const countries = Object.keys(countryNames);
            
            const flags = countries.map((emoji, i) => {
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * (radius - 50);
              return {
                x: centerX + Math.cos(angle) * distance,
                y: centerY + Math.sin(angle) * distance,
                vx: (Math.random() - 0.5) * 48,
                vy: (Math.random() - 0.5) * 48,
                size: 26,
                emoji: emoji,
                exitedCircle: false
              };
            });
            
            const gravity = 1.2;
            
            const playBounceSound = () => {
              const audioContext = new (window.AudioContext || window.webkitAudioContext)();
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);
              
              oscillator.frequency.value = 200 + Math.random() * 150;
              oscillator.type = 'sine';
              
              gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
              
              oscillator.start(audioContext.currentTime);
              oscillator.stop(audioContext.currentTime + 0.1);
            };
            
            let isPausedLocal = false;
            
            const draw = () => {
              if (isPausedLocal || winner) return;
              
              ctx.clearRect(0, 0, width, height);
              
              ctx.strokeStyle = '#10b981';
              ctx.lineWidth = 6;
              ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
              
              flags.forEach(flag => {
                if (flag.exitedCircle) {
                  flag.vy += gravity;
                }
                
                flag.x += flag.vx;
                flag.y += flag.vy;
                
                if (!flag.exitedCircle) {
                  const dx = flag.x - centerX;
                  const dy = flag.y - centerY;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  if (distance + flag.size / 2 > radius) {
                    let angle = Math.atan2(dy, dx);
                    if (angle < 0) angle += Math.PI * 2;
                    
                    let normalizedRotation = rotation % (Math.PI * 2);
                    if (normalizedRotation < 0) normalizedRotation += Math.PI * 2;
                    
                    let flagAngle = angle - normalizedRotation;
                    if (flagAngle < 0) flagAngle += Math.PI * 2;
                    
                    const isInGap = flagAngle > (Math.PI * 2 * 0.90);
                    
                    if (isInGap) {
                      flag.exitedCircle = true;
                    } else {
                      // DVD-style bounce - just reverse the velocity component
                      const nx = dx / distance;
                      const ny = dy / distance;
                      
                      const dotProduct = flag.vx * nx + flag.vy * ny;
                      flag.vx -= 2 * dotProduct * nx;
                      flag.vy -= 2 * dotProduct * ny;
                      
                      const overlap = distance + flag.size / 2 - radius;
                      flag.x -= overlap * nx;
                      flag.y -= overlap * ny;
                      
                      playBounceSound();
                    }
                  }
                }
                
                if (flag.exitedCircle) {
                  const halfSize = flag.size / 2;
                  
                  if (flag.x - halfSize < rect.x) {
                    flag.x = rect.x + halfSize;
                    flag.vx *= -0.7;
                  }
                  if (flag.x + halfSize > rect.x + rect.width) {
                    flag.x = rect.x + rect.width - halfSize;
                    flag.vx *= -0.7;
                  }
                  if (flag.y + halfSize >= rect.y + rect.height) {
                    flag.y = rect.y + rect.height - halfSize;
                    if (flag.vy > 0.5) {
                      flag.vy *= -0.6;
                    } else {
                      flag.vy = 0;
                    }
                    flag.vx *= 0.85;
                  }
                }
              });
              
              for (let i = 0; i < flags.length; i++) {
                for (let j = i + 1; j < flags.length; j++) {
                  const flag1 = flags[i];
                  const flag2 = flags[j];
                  
                  const dx = flag2.x - flag1.x;
                  const dy = flag2.y - flag1.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  const minDistance = (flag1.size + flag2.size) / 2;
                  
                  if (distance < minDistance && distance > 0) {
                    // DVD-style collision - swap velocities
                    const tempVx = flag1.vx;
                    const tempVy = flag1.vy;
                    flag1.vx = flag2.vx;
                    flag1.vy = flag2.vy;
                    flag2.vx = tempVx;
                    flag2.vy = tempVy;
                    
                    // Separate flags to prevent overlap
                    const nx = dx / distance;
                    const ny = dy / distance;
                    const overlap = minDistance - distance;
                    const separationX = (overlap / 2) * nx;
                    const separationY = (overlap / 2) * ny;
                    
                    flag1.x -= separationX;
                    flag1.y -= separationY;
                    flag2.x += separationX;
                    flag2.y += separationY;
                  }
                }
              }
              
              const flagsInCircle = flags.filter(f => !f.exitedCircle);
              setFlagsRemaining(flagsInCircle.length);
              
              if (flagsInCircle.length === 1 && !winner) {
                const winningFlag = flagsInCircle[0].emoji;
                const winningName = countryNames[winningFlag] || 'Unknown';
                setWinner(winningFlag);
                setWinnerName(winningName);
                
                setRecentWinners(prev => {
                  const newWinners = [{ emoji: winningFlag, name: winningName, round: roundNumber }, ...prev];
                  return newWinners.slice(0, 5);
                });
                
                isPausedLocal = true;
                
                setTimeout(() => {
                  setShowWinner(true);
                }, 2000);
                
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const duration = 2;
                const bufferSize = audioContext.sampleRate * duration;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                  data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioContext.sampleRate * 0.5));
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1000;
                filter.Q.value = 1;
                
                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                noise.start(audioContext.currentTime);
                noise.stop(audioContext.currentTime + duration);
                
                const newConfetti = [];
                for (let i = 0; i < 150; i++) {
                  newConfetti.push({
                    x: Math.random() * 1200,
                    y: -20 - Math.random() * 100,
                    vx: (Math.random() - 0.5) * 4,
                    vy: Math.random() * 3 + 2,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10,
                    color: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#ff69b4'][Math.floor(Math.random() * 8)],
                    size: Math.random() * 8 + 4
                  });
                }
                setConfetti(newConfetti);
              }
              
              ctx.save();
              ctx.translate(centerX, centerY);
              ctx.rotate(rotation);
              
              ctx.strokeStyle = '#3b82f6';
              ctx.lineWidth = 6;
              ctx.beginPath();
              ctx.arc(0, 0, radius, 0, Math.PI * 2 * 0.90);
              ctx.stroke();
              
              ctx.restore();
              
              rotation += 0.02;
              
              flags.forEach(flag => {
                ctx.font = `${flag.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(flag.emoji, flag.x, flag.y);
              });
              
              requestAnimationFrame(draw);
            };
            
            let animationId = requestAnimationFrame(draw);
            
            return () => cancelAnimationFrame(animationId);
          }, [winner, winnerName, roundNumber, isPaused]);
          
          useEffect(() => {
            if (confetti.length === 0) return;
            
            const interval = setInterval(() => {
              setConfetti(prevConfetti => {
                return prevConfetti.map(particle => ({
                  ...particle,
                  x: particle.x + particle.vx,
                  y: particle.y + particle.vy,
                  vy: particle.vy + 0.2,
                  rotation: particle.rotation + particle.rotationSpeed
                })).filter(particle => particle.y < 1000);
              });
            }, 1000 / 60);
            
            return () => clearInterval(interval);
          }, [confetti.length > 0]);
          
          useEffect(() => {
            if (winner) {
              const timeout = setTimeout(() => {
                setWinner(null);
                setWinnerName('');
                setShowWinner(false);
                setRoundNumber(prev => prev + 1);
                setIsPaused(false);
                setConfetti([]);
                flagsRef.current = null;
              }, 7000);
              
              return () => clearTimeout(timeout);
            }
          }, [winner]);
          
          useEffect(() => {
            if (showWinner) {
              const timeout = setTimeout(() => {
                setShowWinner(false);
              }, 5000);
              
              return () => clearTimeout(timeout);
            }
          }, [showWinner]);

          return (
            <div className="flex items-center justify-center min-h-screen bg-gray-900 gap-4 p-4">
              <div className="relative">
                <canvas
                  ref={canvasRef}
                  width={1200}
                  height={900}
                  className="border-4 border-gray-700 rounded-lg bg-gray-800"
                />
                
                {confetti.map((particle, i) => (
                  <div
                    key={i}
                    className="absolute"
                    style={{
                      left: particle.x,
                      top: particle.y,
                      width: particle.size,
                      height: particle.size,
                      backgroundColor: particle.color,
                      transform: `rotate(${particle.rotation}deg)`,
                      borderRadius: '2px'
                    }}
                  />
                ))}
                
                <div className="absolute top-4 left-4 bg-black bg-opacity-70 text-white px-4 py-2 rounded-lg">
                  <div className="text-xl font-bold">Round: {roundNumber}</div>
                  <div className="text-xl font-bold">Flags Remaining: {flagsRemaining}</div>
                </div>
                
                {showWinner && (
                  <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 rounded-lg">
                    <div className="text-center animate-bounce">
                      <h1 className="text-6xl mb-4 font-bold text-yellow-400">üèÜ WINNER! üèÜ</h1>
                      <div className="text-9xl mb-4">{winner}</div>
                      <p className="text-4xl font-bold text-white mb-2">{winnerName}</p>
                      <p className="text-2xl text-gray-300">Last Flag Standing!</p>
                      <p className="text-xl text-yellow-300 mt-4">({flagsRemaining} remaining)</p>
                    </div>
                  </div>
                )}
              </div>
              
              <div className="bg-gray-800 border-4 border-gray-700 rounded-lg p-4 w-80">
                <h2 className="text-2xl font-bold text-yellow-400 mb-4 text-center">üèÜ Last 5 Winners</h2>
                <div className="space-y-3">
                  {recentWinners.length === 0 ? (
                    <p className="text-gray-400 text-center">No winners yet!</p>
                  ) : (
                    recentWinners.map((w, index) => (
                      <div 
                        key={index} 
                        className="bg-gray-700 rounded-lg p-3 flex items-center gap-3 border-2 border-gray-600"
                      >
                        <div className="text-5xl">{w.emoji}</div>
                        <div className="flex-1">
                          <p className="text-white font-bold text-lg">{w.name}</p>
                          <p className="text-gray-400 text-sm">Round {w.round}</p>
                        </div>
                        <div className="text-2xl text-yellow-400">
                          {index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÖ'}
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<FlagBounceGame />, document.getElementById('root'));
    </script>
</body>
</html>
