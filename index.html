<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flag Bounce Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #e64d94 0%, #33ebd2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 16px;
      padding: 0;
    }
    
    .game-container {
      position: relative;
    }
    
    canvas {
      background: transparent;
      width: 100vw;
      height: 100vh;
      display: block;
    }
    
    .draggable-panel {
      position: fixed;
      top: 30px;  /* Moved 3px up from 20px */
      right: 20px;
      width: 200px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      cursor: move;
      user-select: none;
      z-index: 1000;
    }
    
    #lastSeriesWinnerPanel {
      height: auto !important;
      min-height: 100px;
      width: 250px !important;
    }
    
    .panel-header {
      background: #333;
      color: white;
      padding: 8px 12px;
      border-radius: 8px 8px 0 0;
      font-size: 14px;
      font-weight: bold;
    }
    
    #lastSeriesWinnerPanel .panel-header {
      padding: 6px 12px;
      font-size: 12px;
    }
    
    .panel-content {
      padding: 8px;
      font-size: 12px;
    }
    
    #lastSeriesWinnerPanel .panel-content {
      padding: 4px;
      font-size: 11px;
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
    }
    
    .country-item {
      display: flex;
      align-items: center;
      padding: 4px 6px;
      margin: 2px 0;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 4px;
      border-left: 3px solid #333;
    }
    
    #lastSeriesWinnerPanel .country-item {
      padding: 2px 4px;
      margin: 1px 0;
      border-radius: 3px;
      border-left: 2px solid #333;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      min-width: 0;
    }
    
    .country-rank {
      font-weight: bold;
      margin-right: 6px;
      min-width: 20px;
    }
    
    #lastSeriesWinnerPanel .country-rank {
      margin-right: 0;
      min-width: auto;
      font-size: 10px;
      margin-bottom: 2px;
    }
    
    .country-flag {
      font-size: 16px;
      margin-right: 6px;
    }
    
    #lastSeriesWinnerPanel .country-flag {
      font-size: 14px;
      margin-right: 0;
      margin-bottom: 2px;
    }
    
    .country-info {
      flex: 1;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .country-name {
      font-weight: 500;
    }
    
    #lastSeriesWinnerPanel .country-info {
      flex: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    #lastSeriesWinnerPanel .country-name {
      font-size: 10px;
      text-align: center;
      line-height: 1.2;
    }
    
    .country-wins {
      font-size: 11px;
      color: #666;
      font-weight: bold;
    }
    
  </style>
</head>
<body>
  
  <div class="game-container">
    <canvas id="gameCanvas"></canvas>
  </div>

  <div class="draggable-panel" id="controlPanel">
    <div class="panel-header">Top 10 Countries</div>
    <div class="panel-content" id="topCountriesList">
      <div>Loading...</div>
    </div>
  </div>

  <div class="draggable-panel" id="lastSeriesWinnerPanel">
    <div class="panel-header">Last 3 Series Winners</div>
    <div class="panel-content" id="lastSeriesWinnerContent">
      <div>No previous series winners</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    canvas.width = width;
    canvas.height = height;
    
    const centerX = width / 2;
    const centerY = height / 2 - 120 + 80 + 30;  // Moved circle down by 30px total
    const radius = 200;
    
    const rectCenterY = height / 2 - 120 + 30;  // Moved rectangle down by 30px total
    
    const rect = {
      width: 520,
      height: 720,
      get x() { return centerX - this.width / 2; },
      get y() { return rectCenterY - this.height / 2 + 200; }
    };
    
    // Guide rectangle configuration
    const guideConfig = {
      ratio: '9:16',  // Locked aspect ratio
      scale: 1.8,     // Scale factor (adjust manually)
      offsetX: 0,     // Horizontal offset from main rect (adjust manually)
      offsetY: 15,  // Vertical offset from main rect (adjust manually)
      centered: true  // Keep rectangle centered
    };
    
    // Add guide rectangle with configurable position and scale
    const guideRect = {
      get ratioWidth() { return 16; },
      get ratioHeight() { return 9; },
      get baseWidth() { return rect.width * guideConfig.scale; },
      get baseHeight() { return (this.baseWidth / this.ratioWidth) * this.ratioHeight; },
      get width() { return this.baseWidth; },  // For 90Â° rotation, swap dimensions
      get height() { return this.baseHeight; },
      get x() { 
        if (guideConfig.centered) {
          return centerX - this.width / 2 + guideConfig.offsetX;
        } else {
          return rect.x + guideConfig.offsetX;
        }
      },
      get y() { 
        if (guideConfig.centered) {
          return centerY - this.height / 2 + guideConfig.offsetY;
        } else {
          return rect.y + guideConfig.offsetY;
        }
      }
    };
    
    let rotation = 0;
    let roundNumber = 1;
    let winner = null;
    let winnerName = '';
    let recentWinners = [];
    let slowMotion = false;
    let hasTriggeredReset = false;
    let resetTimer = null;
    let countryWins = {};  // Track wins for each country
    let gamePaused = false;  // Track if game is paused for 10-win announcement
    let tenWinPauseTimer = null;  // Timer for 10-win pause
    let lastSeriesWinners = [];  // Track last 3 series winners
    let roundStartTime = Date.now();  // Track when each round starts
    let gapOpen = false;  // Track if gap is open
    
    const countryNames = {
      'ðŸ‡ºðŸ‡¸': 'United States', 'ðŸ‡¬ðŸ‡§': 'United Kingdom', 'ðŸ‡¨ðŸ‡¦': 'Canada', 'ðŸ‡¦ðŸ‡º': 'Australia', 'ðŸ‡©ðŸ‡ª': 'Germany',
      'ðŸ‡«ðŸ‡·': 'France', 'ðŸ‡®ðŸ‡¹': 'Italy', 'ðŸ‡ªðŸ‡¸': 'Spain', 'ðŸ‡³ðŸ‡±': 'Netherlands', 'ðŸ‡¸ðŸ‡ª': 'Sweden',
      'ðŸ‡³ðŸ‡´': 'Norway', 'ðŸ‡©ðŸ‡°': 'Denmark', 'ðŸ‡«ðŸ‡®': 'Finland', 'ðŸ‡µðŸ‡±': 'Poland', 'ðŸ‡¨ðŸ‡¿': 'Czech Republic',
      'ðŸ‡¦ðŸ‡¹': 'Austria', 'ðŸ‡¨ðŸ‡­': 'Switzerland', 'ðŸ‡§ðŸ‡ª': 'Belgium', 'ðŸ‡®ðŸ‡ª': 'Ireland', 'ðŸ‡µðŸ‡¹': 'Portugal',
      'ðŸ‡¬ðŸ‡·': 'Greece', 'ðŸ‡·ðŸ‡´': 'Romania', 'ðŸ‡­ðŸ‡º': 'Hungary', 'ðŸ‡·ðŸ‡º': 'Russia', 'ðŸ‡ºðŸ‡¦': 'Ukraine',
      'ðŸ‡¯ðŸ‡µ': 'Japan', 'ðŸ‡°ðŸ‡·': 'South Korea', 'ðŸ‡¨ðŸ‡³': 'China', 'ðŸ‡®ðŸ‡³': 'India', 'ðŸ‡¹ðŸ‡­': 'Thailand',
      'ðŸ‡»ðŸ‡³': 'Vietnam', 'ðŸ‡µðŸ‡­': 'Philippines', 'ðŸ‡®ðŸ‡©': 'Indonesia', 'ðŸ‡²ðŸ‡¾': 'Malaysia', 'ðŸ‡¸ðŸ‡¬': 'Singapore',
      'ðŸ‡¹ðŸ‡¼': 'Taiwan', 'ðŸ‡­ðŸ‡°': 'Hong Kong', 'ðŸ‡³ðŸ‡¿': 'New Zealand', 'ðŸ‡¿ðŸ‡¦': 'South Africa', 'ðŸ‡¦ðŸ‡ª': 'UAE',
      'ðŸ‡¸ðŸ‡¦': 'Saudi Arabia', 'ðŸ‡¹ðŸ‡·': 'Turkey', 'ðŸ‡®ðŸ‡±': 'Israel', 'ðŸ‡ªðŸ‡¬': 'Egypt', 'ðŸ‡²ðŸ‡½': 'Mexico',
      'ðŸ‡§ðŸ‡·': 'Brazil', 'ðŸ‡¦ðŸ‡·': 'Argentina', 'ðŸ‡¨ðŸ‡±': 'Chile', 'ðŸ‡¨ðŸ‡´': 'Colombia', 'ðŸ‡µðŸ‡ª': 'Peru',
      'ðŸ‡»ðŸ‡ª': 'Venezuela', 'ðŸ‡ªðŸ‡¨': 'Ecuador', 'ðŸ‡¨ðŸ‡·': 'Costa Rica', 'ðŸ‡µðŸ‡¦': 'Panama', 'ðŸ‡¨ðŸ‡º': 'Cuba',
      'ðŸ‡¯ðŸ‡²': 'Jamaica', 'ðŸ‡³ðŸ‡¬': 'Nigeria', 'ðŸ‡°ðŸ‡ª': 'Kenya', 'ðŸ‡¬ðŸ‡­': 'Ghana', 'ðŸ‡ªðŸ‡¹': 'Ethiopia',
      'ðŸ‡µðŸ‡°': 'Pakistan', 'ðŸ‡§ðŸ‡©': 'Bangladesh', 'ðŸ‡±ðŸ‡°': 'Sri Lanka', 'ðŸ‡³ðŸ‡µ': 'Nepal', 'ðŸ‡°ðŸ‡¿': 'Kazakhstan',
      'ðŸ‡²ðŸ‡¦': 'Morocco', 'ðŸ‡¹ðŸ‡³': 'Tunisia', 'ðŸ‡¯ðŸ‡´': 'Jordan', 'ðŸ‡±ðŸ‡§': 'Lebanon'
    };
    
    const countries = Object.keys(countryNames);
    const gravity = 1.2;
    
    function initFlags() {
      return countries.map((emoji) => {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * (radius - 50);
        return {
          x: centerX + Math.cos(angle) * distance,
          y: centerY + Math.sin(angle) * distance,
          vx: (Math.random() - 0.5) * 48,
          vy: (Math.random() - 0.5) * 48,
          size: 30,
          emoji: emoji,
          exitedCircle: false
        };
      }).map(flag => {
        // Ensure minimum speed threshold (10x increase from ~2 to ~20)
        const minSpeed = 20;
        const speed = Math.sqrt(flag.vx * flag.vx + flag.vy * flag.vy);
        if (speed < minSpeed && speed > 0) {
          const scale = minSpeed / speed;
          flag.vx *= scale;
          flag.vy *= scale;
        } else if (speed === 0) {
          // If completely still, give random minimum speed
          const angle = Math.random() * Math.PI * 2;
          flag.vx = Math.cos(angle) * minSpeed;
          flag.vy = Math.sin(angle) * minSpeed;
        }
        return flag;
      });
    }
    
    let flags = initFlags();
    
    let audioContext = null;
    
    function playBounceSound() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 200 + Math.random() * 150;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.1);
    }
    
    function announceWinner(countryEmoji, countryName) {
      // Track wins using flag emoji as key
      if (!countryWins[countryEmoji]) {
        countryWins[countryEmoji] = 0;
      }
      countryWins[countryEmoji]++;
      
      // Check if this country reached 10 wins
      if (countryWins[countryEmoji] === 10) {
        announceTenWinSeriesWinner(countryEmoji, countryName);
        return;  // Don't play regular winner announcement for 10th win
      }
      
      // Play "the winner is" audio first
      const winnerIsAudio = new Audio('voice/the winner is.wav');
      winnerIsAudio.play();
      
      // Play country name audio after delay
      setTimeout(() => {
        const countryAudio = new Audio(`voice/${countryName}.wav`);
        countryAudio.play();
      }, 1200);  // 800ms delay
    }
    
    function announceTenWinSeriesWinner(countryEmoji, countryName) {
      // Pause the game
      gamePaused = true;
      
      // Play "the 10 round series winner is" audio
      const seriesWinnerAudio = new Audio('voice/the 10 round series winner is.wav');
      seriesWinnerAudio.play();
      
      // After 2 seconds, display the flag and play country name
      setTimeout(() => {
        // Display large flag and country name on screen
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, width, height);
        
        // Draw large flag
        ctx.font = '200px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(countryEmoji, centerX, centerY - 50);
        
        // Draw country name
        ctx.font = 'bold 48px Arial';
        ctx.fillStyle = '#fbbf24';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 4;
        ctx.strokeText(countryName, centerX, centerY + 150);
        ctx.fillText(countryName, centerX, centerY + 150);
        
        // Draw "10 Round Series Champion!" text
        ctx.font = 'bold 36px Arial';
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        const championText = '10 Round Series Champion!';
        ctx.strokeText(championText, centerX, centerY - 200);
        ctx.fillText(championText, centerX, centerY - 200);
        ctx.restore();
        
        // Play country name audio
        const countryAudio = new Audio(`voice/${countryName}.wav`);
        countryAudio.play();
        
        // Play clapping sound after country name
        setTimeout(() => {
          const clappingAudio = new Audio('voice/clapping.mp3');
          clappingAudio.play();
        }, 1000); // Play clapping 1 second after country name
      }, 2000);
      
      // Resume game after 10 seconds
      tenWinPauseTimer = setTimeout(() => {
        gamePaused = false;
        // Add the series winner to the list (keep only last 3)
        lastSeriesWinners.unshift({ emoji: countryEmoji, name: countryName });
        if (lastSeriesWinners.length > 3) {
          lastSeriesWinners = lastSeriesWinners.slice(0, 3);
        }
        // Reset the win scores and start new series
        resetSeries();
        resetGame();
      }, 10000);
    }
    
    function resetGame() {
      winner = null;
      winnerName = '';
      roundNumber++;
      slowMotion = false;
      hasTriggeredReset = false;
      flags = initFlags();
      roundStartTime = Date.now();  // Reset round start time
      gapOpen = false;  // Close gap for new round
      
      // Play countdown sound when gap closes (with 0.1s delay)
      setTimeout(() => {
        const countdownAudio = new Audio('voice/321.mp3');
        countdownAudio.play();
      }, 80);
    }
    
    function resetSeries() {
      // Reset all country wins
      countryWins = {};
      roundNumber = 1;
    }
    
    function draw() {
      // Skip drawing if game is paused for 10-win announcement
      if (gamePaused) {
        requestAnimationFrame(draw);
        return;
      }
      
      // Check if 3 seconds have passed and open gap if closed
      const timeSinceRoundStart = Date.now() - roundStartTime;
      if (!gapOpen && timeSinceRoundStart > 3000) {
        gapOpen = true;
      }
      
      ctx.clearRect(0, 0, width, height);
            
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';  // 10% opacity black
      ctx.lineWidth = 3;
      ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
      
      // Draw guide rectangle (16:9, no collisions) - rotated 90 degrees
      ctx.save();
      ctx.translate(guideRect.x + guideRect.width/2, guideRect.y + guideRect.height/2);
      ctx.rotate(Math.PI / 2); // 90 degrees rotation
      ctx.strokeStyle = '#000000';  // Make visible again
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(-guideRect.width/2, -guideRect.height/2, guideRect.width, guideRect.height);
      ctx.setLineDash([]);
      ctx.restore();
      
      flags.forEach(flag => {
        if (flag.exitedCircle) {
          flag.vy += gravity * (slowMotion ? 0.2 : 1);
        }
        
        if (flag.growStartTime) {
          const elapsed = Date.now() - flag.growStartTime;
          const progress = Math.min(elapsed / flag.growDuration, 1);
          const easeProgress = 1 - Math.pow(1 - progress, 3);
          flag.size = flag.originalSize + (flag.targetSize - flag.originalSize) * easeProgress;
        }
        
        const speedMultiplier = slowMotion ? 0.2 : 1;
        flag.x += flag.vx * speedMultiplier;
        flag.y += flag.vy * speedMultiplier;
        
        const dx = flag.x - centerX;
        const dy = flag.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (!flag.exitedCircle) {
          if (distance + flag.size / 2 > radius) {
            let angle = Math.atan2(dy, dx);
            if (angle < 0) angle += Math.PI * 2;
            
            let normalizedRotation = rotation % (Math.PI * 2);
            if (normalizedRotation < 0) normalizedRotation += Math.PI * 2;
            
            let flagAngle = angle - normalizedRotation;
            if (flagAngle < 0) flagAngle += Math.PI * 2;
            
            const isInGap = gapOpen && flagAngle > (Math.PI * 2 * 0.90);
            
            if (isInGap) {
              flag.exitedCircle = true;
              
              
              
              
            } else {
              const nx = dx / distance;
              const ny = dy / distance;
              
              const dotProduct = flag.vx * nx + flag.vy * ny;
              flag.vx -= 2 * dotProduct * nx;
              flag.vy -= 2 * dotProduct * ny;
              
              const overlap = distance + flag.size / 2 - radius;
              flag.x -= overlap * nx;
              flag.y -= overlap * ny;
              
              playBounceSound();
            }
          }
        } else {
          if (distance - flag.size / 2 < radius) {
            let angle = Math.atan2(dy, dx);
            if (angle < 0) angle += Math.PI * 2;
            
            let normalizedRotation = rotation % (Math.PI * 2);
            if (normalizedRotation < 0) normalizedRotation += Math.PI * 2;
            
            let flagAngle = angle - normalizedRotation;
            if (flagAngle < 0) flagAngle += Math.PI * 2;
            
            const isInGap = gapOpen && flagAngle > (Math.PI * 2 * 0.90);
            
            if (!isInGap) {
              const nx = dx / distance;
              const ny = dy / distance;
              
              const dotProduct = flag.vx * nx + flag.vy * ny;
              flag.vx -= 2 * dotProduct * nx;
              flag.vy -= 2 * dotProduct * ny;
              
              const overlap = radius - (distance - flag.size / 2);
              flag.x += overlap * nx;
              flag.y += overlap * ny;
              
              playBounceSound();
            }
          }
        }
        
        if (flag.exitedCircle) {
          const halfSize = flag.size / 2;
          
          // Stronger left boundary collision
          if (flag.x - halfSize < rect.x) {
            flag.x = rect.x + halfSize + 1;  // Add 1px buffer
            flag.vx = Math.abs(flag.vx) * 0.8;  // Ensure positive velocity
          }
          // Stronger right boundary collision
          if (flag.x + halfSize > rect.x + rect.width) {
            flag.x = rect.x + rect.width - halfSize - 1;  // Add 1px buffer
            flag.vx = -Math.abs(flag.vx) * 0.8;  // Ensure negative velocity
          }
          // Stronger bottom boundary collision
          if (flag.y + halfSize >= rect.y + rect.height) {
            flag.y = rect.y + rect.height - halfSize - 1;  // Add 1px buffer
            if (flag.vy > 0.5) {
              flag.vy *= -0.8;  // Stronger bounce
            } else {
              flag.vy = 0;
            }
            flag.vx *= 0.9;  // Less friction
            
            // Ensure minimum speed to prevent flags from stopping
            const minSpeed = 5;
            if (Math.abs(flag.vx) < minSpeed) {
              flag.vx = flag.vx > 0 ? minSpeed : -minSpeed;
            }
          }
          
          // Add top boundary check (in case flags bounce up)
          if (flag.y - halfSize < rect.y) {
            flag.y = rect.y + halfSize + 1;
            flag.vy = Math.abs(flag.vy) * 0.8;
          }
        }
      });
      
      for (let i = 0; i < flags.length; i++) {
        for (let j = i + 1; j < flags.length; j++) {
          const flag1 = flags[i];
          const flag2 = flags[j];
          
          const halfSize1 = flag1.size / 2;
          const halfSize2 = flag2.size / 2;
          
          const left1 = flag1.x - halfSize1;
          const right1 = flag1.x + halfSize1;
          const top1 = flag1.y - halfSize1;
          const bottom1 = flag1.y + halfSize1;
          
          const left2 = flag2.x - halfSize2;
          const right2 = flag2.x + halfSize2;
          const top2 = flag2.y - halfSize2;
          const bottom2 = flag2.y + halfSize2;
          
          const isColliding = !(right1 < left2 || left1 > right2 || bottom1 < top2 || top1 > bottom2);
          
          if (isColliding) {
            const tempVx = flag1.vx;
            const tempVy = flag1.vy;
            flag1.vx = flag2.vx;
            flag1.vy = flag2.vy;
            flag2.vx = tempVx;
            flag2.vy = tempVy;
            
            const overlapX = Math.min(right1 - left2, right2 - left1);
            const overlapY = Math.min(bottom1 - top2, bottom2 - top1);
            
            if (overlapX < overlapY) {
              if (flag1.x < flag2.x) {
                flag1.x -= overlapX / 2;
                flag2.x += overlapX / 2;
              } else {
                flag1.x += overlapX / 2;
                flag2.x -= overlapX / 2;
              }
            } else {
              if (flag1.y < flag2.y) {
                flag1.y -= overlapY / 2;
                flag2.y += overlapY / 2;
              } else {
                flag1.y += overlapY / 2;
                flag2.y -= overlapY / 2;
              }
            }
          }
        }
      }
      
      const flagsInCircle = flags.filter(f => !f.exitedCircle);
      
      if (flagsInCircle.length === 1 && !slowMotion) {
        slowMotion = true;
        const lastFlag = flagsInCircle[0];
        lastFlag.targetSize = 34 * 5;
        lastFlag.originalSize = 34;
        lastFlag.growStartTime = Date.now();
        lastFlag.growDuration = 2000;
        
        const winningName = countryNames[lastFlag.emoji] || 'Unknown';
        announceWinner(lastFlag.emoji, winningName);
        
        if (!hasTriggeredReset) {
          hasTriggeredReset = true;
          resetTimer = setTimeout(() => {
            resetGame();
          }, 5000);
        }
      }
      
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(rotation);
      
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2 * 0.90);
      ctx.stroke();
      
      ctx.restore();
      
      rotation += slowMotion ? 0.004 : 0.02;
      
      flags.forEach(flag => {
        ctx.font = `${flag.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(flag.emoji, flag.x, flag.y);
        
        if (slowMotion && !flag.exitedCircle) {
          ctx.font = 'bold 36px Arial';
          ctx.fillStyle = '#fbbf24';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3;
          ctx.strokeText('WINNER', flag.x, flag.y + flag.size / 2 + 50);
          ctx.fillText('WINNER', flag.x, flag.y + flag.size / 2 + 50);
          
          const countryName = countryNames[flag.emoji] || 'Unknown';
          ctx.font = 'bold 28px Arial';
          ctx.fillStyle = '#fff';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.strokeText(countryName, flag.x, flag.y + flag.size / 2 + 90);
          ctx.fillText(countryName, flag.x, flag.y + flag.size / 2 + 90);
        }
      });
      
      requestAnimationFrame(draw);
    }
    
    draw();
    
    // Draggable panel functionality
    const panel = document.getElementById('controlPanel');
    const lastWinnerPanel = document.getElementById('lastSeriesWinnerPanel');
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let currentDraggingPanel = null;
    
    // Load saved position from localStorage
    function loadPanelPosition() {
      // Load control panel position
      const savedPosition = localStorage.getItem('panelPosition');
      if (savedPosition) {
        const position = JSON.parse(savedPosition);
        panel.style.left = position.left + 'px';
        panel.style.top = position.top + 'px';
        panel.style.right = 'auto'; // Disable right positioning when using left
        console.log('Loaded position:', position);
      } else {
        // Set default position to current CSS position (top: 30px, right: 20px)
        const defaultLeft = window.innerWidth - 220; // 200px width + 20px right margin
        const defaultTop = 30;
        panel.style.left = defaultLeft + 'px';
        panel.style.top = defaultTop + 'px';
        panel.style.right = 'auto';
        // Save this as the default position
        savePanelPosition();
        console.log('Set default position:', { left: defaultLeft, top: defaultTop });
      }
      
      // Load last winner panel position
      const savedLastWinnerPosition = localStorage.getItem('lastWinnerPanelPosition');
      if (savedLastWinnerPosition) {
        const position = JSON.parse(savedLastWinnerPosition);
        lastWinnerPanel.style.left = position.left + 'px';
        lastWinnerPanel.style.top = position.top + 'px';
        lastWinnerPanel.style.right = 'auto';
        console.log('Loaded last winner panel position:', position);
      } else {
        // Set default position for last winner panel (below control panel)
        const defaultLeft = window.innerWidth - 220;
        const defaultTop = 250; // Below control panel
        lastWinnerPanel.style.left = defaultLeft + 'px';
        lastWinnerPanel.style.top = defaultTop + 'px';
        lastWinnerPanel.style.right = 'auto';
        saveLastWinnerPanelPosition();
        console.log('Set default last winner panel position:', { left: defaultLeft, top: defaultTop });
      }
    }
    
    // Save position to localStorage
    function savePanelPosition() {
      const position = {
        left: panel.offsetLeft,
        top: panel.offsetTop
      };
      localStorage.setItem('panelPosition', JSON.stringify(position));
      console.log('Saved position:', position); // Debug log
    }
    
    function saveLastWinnerPanelPosition() {
      const position = {
        left: lastWinnerPanel.offsetLeft,
        top: lastWinnerPanel.offsetTop
      };
      localStorage.setItem('lastWinnerPanelPosition', JSON.stringify(position));
      console.log('Saved last winner panel position:', position);
    }
    
    // Load position on page load
    loadPanelPosition();
    
    panel.addEventListener('mousedown', (e) => {
      isDragging = true;
      currentDraggingPanel = panel;
      dragOffsetX = e.clientX - panel.offsetLeft;
      dragOffsetY = e.clientY - panel.offsetTop;
      panel.style.cursor = 'grabbing';
    });
    
    lastWinnerPanel.addEventListener('mousedown', (e) => {
      isDragging = true;
      currentDraggingPanel = lastWinnerPanel;
      dragOffsetX = e.clientX - lastWinnerPanel.offsetLeft;
      dragOffsetY = e.clientY - lastWinnerPanel.offsetTop;
      lastWinnerPanel.style.cursor = 'grabbing';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (isDragging && currentDraggingPanel) {
        const newX = e.clientX - dragOffsetX;
        const newY = e.clientY - dragOffsetY;
        
        // Keep panel within viewport bounds
        const maxX = window.innerWidth - currentDraggingPanel.offsetWidth;
        const maxY = window.innerHeight - currentDraggingPanel.offsetHeight;
        
        currentDraggingPanel.style.left = Math.max(0, Math.min(newX, maxX)) + 'px';
        currentDraggingPanel.style.top = Math.max(0, Math.min(newY, maxY)) + 'px';
        currentDraggingPanel.style.right = 'auto'; // Disable right positioning
      }
    });
    
    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        currentDraggingPanel.style.cursor = 'move';
        
        // Save position based on which panel was being dragged
        if (currentDraggingPanel === panel) {
          savePanelPosition();
        } else if (currentDraggingPanel === lastWinnerPanel) {
          saveLastWinnerPanelPosition();
        }
        
        currentDraggingPanel = null;
      }
    });
    
    // Also save position when window is resized (in case bounds change)
    window.addEventListener('resize', () => {
      savePanelPosition();
      saveLastWinnerPanelPosition();
    });
    
    // Update panel displays
    function updatePanel() {
      // Get top 10 countries by wins
      const sortedCountries = Object.entries(countryWins)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      // Generate HTML for top countries list
      let html = '';
      sortedCountries.forEach(([countryKey, wins], index) => {
        const countryName = countryNames[countryKey] || countryKey;
        const winText = wins === 1 ? '1 win' : `${wins} wins`;
        html += `
          <div class="country-item">
            <span class="country-rank">#${index + 1}</span>
            <span class="country-flag">${countryKey}</span>
            <div class="country-info">
              <span class="country-name">${countryName}</span>
              <span class="country-wins">${winText}</span>
            </div>
          </div>
        `;
      });
      
      // If no wins yet, show message
      if (sortedCountries.length === 0) {
        html = '<div style="text-align: center; padding: 20px; color: #666;">No wins yet</div>';
      }
      
      document.getElementById('topCountriesList').innerHTML = html;
      
      requestAnimationFrame(updatePanel);
    }
    updatePanel();
    
    // Update last series winner panel separately
    function updateLastSeriesWinnerPanel() {
      lastWinnerPanel.style.display = 'block';
      if (lastSeriesWinners.length > 0) {
        let html = '';
        lastSeriesWinners.forEach((winner, index) => {
          const rankNumber = index + 1;
          html += `
            <div class="country-item">
              <span class="country-rank">#${rankNumber}</span>
              <span class="country-flag" style="font-size: 20px;">${winner.emoji}</span>
              <div class="country-info">
                <span class="country-name">${winner.name}</span>
              </div>
            </div>
          `;
        });
        document.getElementById('lastSeriesWinnerContent').innerHTML = html;
      } else {
        document.getElementById('lastSeriesWinnerContent').innerHTML = '<div>No previous series winners</div>';
      }
      
      requestAnimationFrame(updateLastSeriesWinnerPanel);
    }
    updateLastSeriesWinnerPanel();
  </script>
</body>
</html>
