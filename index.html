<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flag Bounce Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #87CEEB 0%, #B0C4DE 50%, #778899 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 16px;
      padding: 0;
      overflow: hidden;
    }
    
    .game-container {
      position: relative;
    }
    
    canvas {
      border: 4px solid #374151;
      border-radius: 8px;
    }
    
    .info-overlay {
      position: absolute;
      top: 16px;
      right: -180px;
      background: rgba(255, 255, 255, 0.9);
      color: #1f2937;
      padding: 8px 16px;
      border-radius: 8px;
      border: 2px solid rgba(0, 0, 0, 0.2);
    }
    
    .info-text {
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      margin: 4px 0;
    }
    
    .sidebar {
      background: transparent;
      border: none;
      border-radius: 8px;
      padding: 6px;
      width: auto;
      max-width: 1200px;
      margin-top: 20px;
    }
    
    .sidebar h2 {
      font-size: 14px;
      font-weight: bold;
      color: #1f2937;
      margin-bottom: 8px;
      text-align: center;
    }
    
    .winners-list {
      display: flex;
      flex-direction: row;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .no-winners {
      color: #4b5563;
      text-align: center;
      font-size: 10px;
    }
    
    .winner-item {
      background: rgba(255, 255, 255, 0.7);
      border-radius: 4px;
      padding: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      border: 2px solid rgba(0, 0, 0, 0.2);
      min-width: 70px;
      text-align: center;
    }
    
    .winner-flag {
      font-size: 36px;
    }
    
    .winner-details {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .winner-name {
      color: #1f2937;
      font-weight: bold;
      font-size: 9px;
    }
    
    .winner-round {
      color: #4b5563;
      font-size: 8px;
    }
    
    .winner-medal {
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <h2>üèÜ Last 5 Winners</h2>
    <div class="winners-list" id="winnersList">
      <p class="no-winners">No winners yet!</p>
    </div>
  </div>
  
  <div class="game-container">
    <canvas id="gameCanvas" width="1200" height="900"></canvas>
    <div class="info-overlay">
      <div class="info-text">Flags Remaining: <span id="flagsRemaining">0</span></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const width = 1200;
    const height = 900;
    
    const centerX = width / 2;
    const centerY = height / 2 - 120;
    const radius = 200;
    
    const rect = {
      width: 650,
      height: 900,
      get x() { return centerX - this.width / 2; },
      get y() { return centerY - this.height / 2 + 60; }
    };
    
    let rotation = 0;
    let roundNumber = 1;
    let winner = null;
    let winnerName = '';
    let recentWinners = [];
    let slowMotion = false;
    let hasTriggeredReset = false;
    let resetTimer = null;
    
    const countryNames = {
      'üá∫üá∏': 'United States', 'üá¨üáß': 'United Kingdom', 'üá®üá¶': 'Canada', 'üá¶üá∫': 'Australia', 'üá©üá™': 'Germany',
      'üá´üá∑': 'France', 'üáÆüáπ': 'Italy', 'üá™üá∏': 'Spain', 'üá≥üá±': 'Netherlands', 'üá∏üá™': 'Sweden',
      'üá≥üá¥': 'Norway', 'üá©üá∞': 'Denmark', 'üá´üáÆ': 'Finland', 'üáµüá±': 'Poland', 'üá®üáø': 'Czech Republic',
      'üá¶üáπ': 'Austria', 'üá®üá≠': 'Switzerland', 'üáßüá™': 'Belgium', 'üáÆüá™': 'Ireland', 'üáµüáπ': 'Portugal',
      'üá¨üá∑': 'Greece', 'üá∑üá¥': 'Romania', 'üá≠üá∫': 'Hungary', 'üá∑üá∫': 'Russia', 'üá∫üá¶': 'Ukraine',
      'üáØüáµ': 'Japan', 'üá∞üá∑': 'South Korea', 'üá®üá≥': 'China', 'üáÆüá≥': 'India', 'üáπüá≠': 'Thailand',
      'üáªüá≥': 'Vietnam', 'üáµüá≠': 'Philippines', 'üáÆüá©': 'Indonesia', 'üá≤üáæ': 'Malaysia', 'üá∏üá¨': 'Singapore',
      'üáπüáº': 'Taiwan', 'üá≠üá∞': 'Hong Kong', 'üá≥üáø': 'New Zealand', 'üáøüá¶': 'South Africa', 'üá¶üá™': 'UAE',
      'üá∏üá¶': 'Saudi Arabia', 'üáπüá∑': 'Turkey', 'üáÆüá±': 'Israel', 'üá™üá¨': 'Egypt', 'üá≤üáΩ': 'Mexico',
      'üáßüá∑': 'Brazil', 'üá¶üá∑': 'Argentina', 'üá®üá±': 'Chile', 'üá®üá¥': 'Colombia', 'üáµüá™': 'Peru',
      'üáªüá™': 'Venezuela', 'üá™üá®': 'Ecuador', 'üá®üá∑': 'Costa Rica', 'üáµüá¶': 'Panama', 'üá®üá∫': 'Cuba',
      'üáØüá≤': 'Jamaica', 'üá≥üá¨': 'Nigeria', 'üá∞üá™': 'Kenya', 'üá¨üá≠': 'Ghana', 'üá™üáπ': 'Ethiopia',
      'üáµüá∞': 'Pakistan', 'üáßüá©': 'Bangladesh', 'üá±üá∞': 'Sri Lanka', 'üá≥üáµ': 'Nepal', 'üá∞üáø': 'Kazakhstan',
      'üá≤üá¶': 'Morocco', 'üáπüá≥': 'Tunisia', 'üáØüá¥': 'Jordan', 'üá±üáß': 'Lebanon'
    };
    
    const countries = Object.keys(countryNames);
    const gravity = 1.2;
    
    function initFlags() {
      return countries.map((emoji) => {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * (radius - 50);
        return {
          x: centerX + Math.cos(angle) * distance,
          y: centerY + Math.sin(angle) * distance,
          vx: (Math.random() - 0.5) * 48,
          vy: (Math.random() - 0.5) * 48,
          size: 26,
          emoji: emoji,
          exitedCircle: false
        };
      });
    }
    
    let flags = initFlags();
    
    let audioContext = null;
    
    function playBounceSound() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 200 + Math.random() * 150;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.1);
    }
    
    function announceWinner(countryName) {
      const utterance = new SpeechSynthesisUtterance(`${countryName} wins!`);
      utterance.rate = 0.9;
      utterance.pitch = 1.2;
      utterance.volume = 1.0;
      
      const voices = window.speechSynthesis.getVoices();
      const femaleVoice = voices.find(voice => 
        voice.name.includes('Female') || 
        voice.name.includes('female') ||
        voice.name.includes('Samantha') ||
        voice.name.includes('Victoria') ||
        voice.name.includes('Karen') ||
        voice.name.includes('Moira') ||
        voice.name.includes('Tessa') ||
        voice.name.includes('Zira') ||
        voice.name.includes('Google UK English Female') ||
        voice.name.includes('Google US English Female')
      );
      
      if (femaleVoice) {
        utterance.voice = femaleVoice;
      }
      
      window.speechSynthesis.speak(utterance);
    }
    
    if (window.speechSynthesis.onvoiceschanged !== undefined) {
      window.speechSynthesis.onvoiceschanged = () => {
        window.speechSynthesis.getVoices();
      };
    }
    
    function updateWinnersList() {
      const listEl = document.getElementById('winnersList');
      if (recentWinners.length === 0) {
        listEl.innerHTML = '<p class="no-winners">No winners yet!</p>';
      } else {
        const medals = ['ü•á', 'ü•à', 'ü•â', 'üèÖ', 'üèÖ'];
        listEl.innerHTML = recentWinners.map((w, i) => `
          <div class="winner-item">
            <div class="winner-medal">${medals[i]}</div>
            <div class="winner-flag">${w.emoji}</div>
            <div class="winner-details">
              <p class="winner-name">${w.name}</p>
              <p class="winner-round">Round ${w.round}</p>
            </div>
          </div>
        `).join('');
      }
    }
    
    function resetGame() {
      winner = null;
      winnerName = '';
      roundNumber++;
      slowMotion = false;
      hasTriggeredReset = false;
      flags = initFlags();
    }
    
    function draw() {
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#87CEEB');
      gradient.addColorStop(0.5, '#B0C4DE');
      gradient.addColorStop(1, '#778899');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 3;
      ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
      
      flags.forEach(flag => {
        if (flag.exitedCircle) {
          flag.vy += gravity * (slowMotion ? 0.2 : 1);
        }
        
        if (flag.growStartTime) {
          const elapsed = Date.now() - flag.growStartTime;
          const progress = Math.min(elapsed / flag.growDuration, 1);
          const easeProgress = 1 - Math.pow(1 - progress, 3);
          flag.size = flag.originalSize + (flag.targetSize - flag.originalSize) * easeProgress;
        }
        
        const speedMultiplier = slowMotion ? 0.2 : 1;
        flag.x += flag.vx * speedMultiplier;
        flag.y += flag.vy * speedMultiplier;
        
        const dx = flag.x - centerX;
        const dy = flag.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (!flag.exitedCircle) {
          if (distance + flag.size / 2 > radius) {
            let angle = Math.atan2(dy, dx);
            if (angle < 0) angle += Math.PI * 2;
            
            let normalizedRotation = rotation % (Math.PI * 2);
            if (normalizedRotation < 0) normalizedRotation += Math.PI * 2;
            
            let flagAngle = angle - normalizedRotation;
            if (flagAngle < 0) flagAngle += Math.PI * 2;
            
            const isInGap = flagAngle > (Math.PI * 2 * 0.90);
            
            if (isInGap) {
              flag.exitedCircle = true;
            } else {
              const nx = dx / distance;
              const ny = dy / distance;
              
              const dotProduct = flag.vx * nx + flag.vy * ny;
              flag.vx -= 2 * dotProduct * nx;
              flag.vy -= 2 * dotProduct * ny;
              
              const overlap = distance + flag.size / 2 - radius;
              flag.x -= overlap * nx;
              flag.y -= overlap * ny;
              
              playBounceSound();
            }
          }
        } else {
          if (distance - flag.size / 2 < radius) {
            let angle = Math.atan2(dy, dx);
            if (angle < 0) angle += Math.PI * 2;
            
            let normalizedRotation = rotation % (Math.PI * 2);
            if (normalizedRotation < 0) normalizedRotation += Math.PI * 2;
            
            let flagAngle = angle - normalizedRotation;
            if (flagAngle < 0) flagAngle += Math.PI * 2;
            
            const isInGap = flagAngle > (Math.PI * 2 * 0.90);
            
            if (!isInGap) {
              const nx = dx / distance;
              const ny = dy / distance;
              
              const dotProduct = flag.vx * nx + flag.vy * ny;
              flag.vx -= 2 * dotProduct * nx;
              flag.vy -= 2 * dotProduct * ny;
              
              const overlap = radius - (distance - flag.size / 2);
              flag.x += overlap * nx;
              flag.y += overlap * ny;
              
              playBounceSound();
            }
          }
        }
        
        if (flag.exitedCircle) {
          const halfSize = flag.size / 2;
          
          if (flag.x - halfSize < rect.x) {
            flag.x = rect.x + halfSize;
            flag.vx *= -0.7;
          }
          if (flag.x + halfSize > rect.x + rect.width) {
            flag.x = rect.x + rect.width - halfSize;
            flag.vx *= -0.7;
          }
          if (flag.y + halfSize >= rect.y + rect.height) {
            flag.y = rect.y + rect.height - halfSize;
            if (flag.vy > 0.5) {
              flag.vy *= -0.6;
            } else {
              flag.vy = 0;
            }
            flag.vx *= 0.85;
          }
        }
      });
      
      for (let i = 0; i < flags.length; i++) {
        for (let j = i + 1; j < flags.length; j++) {
          const flag1 = flags[i];
          const flag2 = flags[j];
          
          const halfSize1 = flag1.size / 2;
          const halfSize2 = flag2.size / 2;
          
          const left1 = flag1.x - halfSize1;
          const right1 = flag1.x + halfSize1;
          const top1 = flag1.y - halfSize1;
          const bottom1 = flag1.y + halfSize1;
          
          const left2 = flag2.x - halfSize2;
          const right2 = flag2.x + halfSize2;
          const top2 = flag2.y - halfSize2;
          const bottom2 = flag2.y + halfSize2;
          
          const isColliding = !(right1 < left2 || left1 > right2 || bottom1 < top2 || top1 > bottom2);
          
          if (isColliding) {
            const tempVx = flag1.vx;
            const tempVy = flag1.vy;
            flag1.vx = flag2.vx;
            flag1.vy = flag2.vy;
            flag2.vx = tempVx;
            flag2.vy = tempVy;
            
            const overlapX = Math.min(right1 - left2, right2 - left1);
            const overlapY = Math.min(bottom1 - top2, bottom2 - top1);
            
            if (overlapX < overlapY) {
              if (flag1.x < flag2.x) {
                flag1.x -= overlapX / 2;
                flag2.x += overlapX / 2;
              } else {
                flag1.x += overlapX / 2;
                flag2.x -= overlapX / 2;
              }
            } else {
              if (flag1.y < flag2.y) {
                flag1.y -= overlapY / 2;
                flag2.y += overlapY / 2;
              } else {
                flag1.y += overlapY / 2;
                flag2.y -= overlapY / 2;
              }
            }
          }
        }
      }
      
      const flagsInCircle = flags.filter(f => !f.exitedCircle);
      document.getElementById('flagsRemaining').textContent = flagsInCircle.length;
      
      if (flagsInCircle.length === 1 && !slowMotion) {
        slowMotion = true;
        const lastFlag = flagsInCircle[0];
        lastFlag.targetSize = 26 * 5;
        lastFlag.originalSize = 26;
        lastFlag.growStartTime = Date.now();
        lastFlag.growDuration = 2000;
        
        const winningName = countryNames[lastFlag.emoji] || 'Unknown';
        announceWinner(winningName);
        
        if (!hasTriggeredReset) {
          hasTriggeredReset = true;
          resetTimer = setTimeout(() => {
            const winningFlag = lastFlag.emoji;
            const winningName = countryNames[winningFlag] || 'Unknown';
            
            recentWinners = [
              { emoji: winningFlag, name: winningName, round: roundNumber },
              ...recentWinners
            ].slice(0, 5);
            updateWinnersList();
            
            resetGame();
          }, 5000);
        }
      }
      
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(rotation);
      
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2 * 0.90);
      ctx.stroke();
      
      ctx.restore();
      
      rotation += slowMotion ? 0.004 : 0.02;
      
      flags.forEach(flag => {
        ctx.font = `${flag.size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(flag.emoji, flag.x, flag.y);
        
        if (slowMotion && !flag.exitedCircle) {
          ctx.font = 'bold 36px Arial';
          ctx.fillStyle = '#fbbf24';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3;
          ctx.strokeText('WINNER', flag.x, flag.y + flag.size / 2 + 50);
          ctx.fillText('WINNER', flag.x, flag.y + flag.size / 2 + 50);
          
          const countryName = countryNames[flag.emoji] || 'Unknown';
          ctx.font = 'bold 28px Arial';
          ctx.fillStyle = '#fff';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.strokeText(countryName, flag.x, flag.y + flag.size / 2 + 90);
          ctx.fillText(countryName, flag.x, flag.y + flag.size / 2 + 90);
        }
      });
      
      requestAnimationFrame(draw);
    }
    
    draw();
  </script>
</body>
</html>
